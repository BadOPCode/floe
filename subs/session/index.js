#!/usr/bin/env node

/**
 * Manages session controls.
 * This provide a means of storing and retrieving low security small data.
 * Shawn Rapp - 4/13/2015
 */

var plsub = require('party-line-sub')('session'),
    MongoClient = require('mongodb').MongoClient;

/**
 * Standard callback.
 *
 * @callback standardCallback
 * @param {Object} error
 * @param {Object} success
 */

plsub.addListeningContext('web.api');
plsub.addListeningContext('api');

var MONGO_URL = 'mongodb://localhost:27017/floe';
var db;
var session_collection;

MongoClient.connect(MONGO_URL, function(err, db_connection) {
    if (!!err) {
        plsub.logger.error(err);
        return;
    }
    plsub.logger.log('Connected to Mongo database.');
    db = db_connection;
    session_collection = db.collection('sessions');
});

var findSessionById = function(search_id, callback) {
    var ObjectID = require('mongodb').ObjectID(search_id);
    var search_obj = {
        _id: ObjectID
    };
    session_collection.findOne(search_obj, function(err, result) {
        if (!!err) { //error occurred while searching for function
            plsub.logger.error(err);
            callback(err, null);
            return;
        }

        if (!result) { //couldn't find session
            callback(new Error('Session' + result + ' does not exist.'), null);
            return;
        }

        callback(null, result);
    });
};

/**
 * generateNewSessionObject - Creates a new session object
 * @param {string} ip_address Client IP address.
 * @param {standardCallback} callback Returns back the session ID generated by Mongo
 */
var generateNewSessionObject = function(ip_address, callback) {
    var session_obj = {
        ip_address: ip_address,
        last_seen: (new Date).valueOf()
    };
    session_collection.insert(session_obj, function(err, result) {
        if (!!err) { //error occurred while searching for function
            plsub.logger.error(err);
        }
        var ObjectID = require('mongodb').ObjectID(result.ops[0]._id.id);

        callback(err, ObjectID);
    });
};

var appendSessionObject = function(session_id, update_obj, callback) {
    var search_obj = {
        _id: session_id
    };
    update_obj.last_seen = (new Date).valueOf();
    var data_obj = {
        $set: update_obj
    };
    session_collection.update(search_obj, data_obj, function(err, result) {
        if (!!err) { //error occurred while searching for function
            plsub.logger.error(err);
        }
        callback(err, result.ops);
    });
};

var removeSessionObject = function(session_id, callback) {
    var search_obj = {
        _id: session_id
    };
    session_collection.remove(search_obj, function(err, result) {
        if (!!err) { //error occurred while searching for function
            plsub.logger.error(err);
        }
        callback(err, result);
    });
};

var cleanSessionObjects = function() {};

/**
 * Sends a packet to reject the request.
 * @param {Object} request_packet Incoming packet from PL.
 */
function sendNoReponsePacket(request_packet) {
    var noroute_packet = {
        type: 'noResponse',
        context: request_packet.from,
        request_id: request_packet.request_id
    };
    plsub.send(noroute_packet);
}

/**
 * sends a results packet
 * @param {Object} request_packet Incoming packet from PL
 * @param {Object} err Error results object (only defined if there is an error)
 * @param {Object} result Result is what help methods pass back when successfully executed.
 */
function sendStatusPacket(request_packet, err, result) {
    var result_packet = {
        type: 'response',
        original_request: request_packet.type,
        context: request_packet.from,
        request_id: request_packet.request_id,
    };

    if (!err) {
        result_packet.status = 'nominal';
    }
    else {
        result_packet.status = 'error';
        result_packet.error = err;
    }
    plsub.send(result_packet);
}

function sendSessionObjectPacket(request_packet, err, session_object) {
    var result_packet = {
        type: 'response',
        original_request: request_packet.type,
        context: request_packet.from,
        request_id: request_packet.request_id,
    };
    if (!err) {
        result_packet.status = 'nominal';
        session_object._id = require('mongodb').ObjectID(session_object._id).toHexString();
        result_packet.session_object = session_object;
    }
    else {
        result_packet.status = 'error';
        result_packet.error = err;
    }
    plsub.logger.info('result_packet', result_packet);
    plsub.send(result_packet);
}

/**
 * Filters incoming packet requests for packets only relevant to this sub.
 * @param {Object} request_packet  Incoming packet from PL.
 */
// function filterRequests(request_packet) {
//     executeRequests(request_packet);
// }

function sendSetSessionCookie(request_packet, session_id) {
    plsub.logger.warn('request_packet', request_packet);
    var cookie_packet = {
        type: 'setCookie',
        context: request_packet.from,
        request_id: request_packet.request_id,
        cookie_name: 'session_id',
        cookie_value: session_id
    }
    plsub.send(cookie_packet);
}


plsub.on('session-generate', function(request_packet) {
    generateNewSessionObject(request_packet.ip_address, function(err, result) {
        plsub.logger.info('Session ID:' + result);
        sendStatusPacket(request_packet, err, result);
        sendSetSessionCookie(request_packet, result);
    });
});

plsub.on('session-retrieve', function(request_packet) {
    findSessionById(request_packet.session_id, function(err, result) {
        sendSessionObjectPacket(request_packet, err, result);
    });
});

plsub.on('session-append', function(request_packet) {
    appendSessionObject(request_packet.session_id, request_packet.data, function(err, result) {
        sendStatusPacket(request_packet, err, result);
    });
});

plsub.on('session-remove', function(request_packet) {
    removeSessionObject(request_packet.session_id, function(err, result) {
        sendStatusPacket(request_packet, err, result);
    });
});